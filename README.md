# encrypted_yd


### Пакет предназначен для хранения файлов на YandexDisk (YD) в зашифрованном виде. 


> Содержимое файлов перед отправкой на YD шифруются. Имена файлов и/или директорий преобразуются в произвольные названия, получаемые с помощью `uuid4()`, при этом исходные имена сохраняются в специальные структуры, ассоциированные, соответственно, с файлами и директориями на YD (API YD предусматривает возможность прикрепления к файлу или директории дополнительной пользовательской информации, хранимой в специальной структуре). При скачивании на локальный диск содержимое фалов, их имена, а также имена директорий восстанавливаются (преобразуются к исходному виду).


##### Пример использования пакета


Выполняем импорт:
```
from encrypted_yd.encrypted_yd import EncryptedYandexDisk
```


Задаем путь приложения на YD (в терминологии API YD):
```
app_remote_base_path: str = '/Приложения/demo/'
```


Если мы хотим, чтобы пользователь ввел пароль вручную:
```
print('Введите пароль:')
password = getpass.getpass()
```   


Для демонстрационных целей, пароль хранится в открытом виде (при реальном использовании __так делать не нужно__):
```
password = 'ТестовыйПароль'
```


В данном примере использован токен `"AQAAAABBnepFAAdOwRtowb-H_EO2gEk0DA3_IHs"` (в настоящее время он заблокирован автором по понятным причинам). 
Ниже этот токен представлен в зашифрованном виде - __так его можно безопасно хранить прямо в файле__:
```
encrypted_token = b's\xf5\xac\xce98B\x89\xe29|/\x8b\x9c\xed\x80\xc0\xfc)\xf7\xd9sa\r\x86\xb5\xee\xc8rq\x1b\x9e\xe3s W\xbcrI\xfa\x1ee/\xf2\xe6\xbb#]}\x88\xfb\xec\xc2\xa8\xeak\xc0\x0e\x03[\x8c\xdf~\xda%\xd1\xca\xe0\xcfP\xfa'
```


>Чтобы получить зашифрованный токен из исходного необходимо:
>```
>from encrypted_yd.cryptography import CryptodomeAES
>caes = CryptodomeAES(password.encode('utf8'))
>encrypted_token = caes.encrypt_data(token.encode('utf-8'))
>```
>Достаточно выполнить эти операции один раз для конкретного пароля и токена, а в дальнейшем использовать полученный результат.


Теперь можем создать экземпляр класса для работы с YD:
```
eyd = EncryptedYandexDisk(app_remote_base_path, encrypted_token, password)
```


Шифруем и отправляем файлы и директории на YD:
```
eyd.send_files_and_dirs('d:/test/', app_remote_base_path)
```


Скачиваем и расшифровываем файлы и директории с YD в локальный каталог:
```
eyd.receive_files_and_dirs('d:/test_recieve/', app_remote_base_path)
```


Получаем перечень ресурсов на YD, расположенных в корневой папке приложения:
```
dict_of_remote_files_and_dirs = eyd.list_files_and_dirs(app_remote_base_path)
```


Перечень представляет собой словарь, состоящий из двух словарей. Первый словарь `'uuids'` в качестве ключей содержит имена ресурсов на YD (если ресурсы были отправлены на YD с помощью пакета `encrypted_yd`, то их имена будут в формате __uuid4__), в качестве значений - кортежи вида (___'исходное имя ресурса'___, ___'размер'___, ___'тип ресурса (dir или file)'___). Второй словарь `'names'` в качестве  ключей содержит исходные имена ресурсов, а в качестве значений - имена этих же ресурсов на YD (теоретически последних может быть несколько, поэтому они помещены во множество `set`, однако пакет `crypto_yd` при отправке файлов или директорий __не создает ненужных копий на YD__).


Теперь удаляем все файлы из корневой директории:
```
for uuid in dict_of_remote_files_and_dirs['uuids']:
    eyd.remove(f'{app_remote_base_path}{uuid}')
```


Параметр `'permanently'`, неявно передаваемый в метод `'remove'`, по умолчанию равен `True` - удаляем файлы и директории, находящиеся на YD, навсегда, без помещения их в корзину. Чтобы удалить файлы и директории через корзину, используйте:
 ```
 eyd.remove(app_remote_base_path+res_name_in_uuid_format, permanently=False))
```


Приятной работы!